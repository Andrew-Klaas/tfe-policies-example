import "tfplan"

# Flatten tfplan's nested resource maps:
#   {"name": {"0": {"applied": {...}, "diff": {...} }, "1": {...}}, "name": {...}}
# ...to an array of resource bodies:
#   [{"applied": {...}, "diff": {...}}, {"applied": {...}, "diff": {...}}, ...]
get_resource_bodies = func(named_and_counted_resources) {
	result = []
	for named_and_counted_resources as _, instances {
		for instances as _, body {
			append(result, body)
		}
	}
	return result
}

# Get an array of all resources of the given type (or an empty array).
get_resources = func(type) {
	resources = []
	if length(tfplan.module_paths else []) > 0 { # always true in the real tfplan import
		for tfplan.module_paths as path {
			nested_resources = tfplan.module(path).resources[type] else {}
			resources += get_resource_bodies(nested_resources)
		}
	} else { # fallback for tests
		nested_resources = tfplan.resources[type] else {}
		resources += get_resource_bodies(nested_resources)
	}
	return resources
}

# comparison is case-sensitive
# so including both cases for "v"
# since we have seen both used
allowed_vm_sizes = [
	"Standard_D1_v2",
	"Standard_D1_V2",
	"Standard_D2_v2",
	"Standard_D2_V2",
	"Standard_DS1_v2",
	"Standard_DS1_V2",
	"Standard_DS2_v2",
	"Standard_DS2_V2",
	"Standard_A1",
	"Standard_A2",
	"Standard_D1",
	"Standard_D2",
]

vm_size_allowed = rule {
	all get_resources("azurerm_virtual_machine") as r {
		r.applied.vm_size in allowed_vm_sizes
	}
}

main = rule {
	(vm_size_allowed) else true
}